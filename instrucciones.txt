# Practica 008 - Building **Infinite List**

## Introducción

¿Alguna vez has hecho scroll sin pensar en TikTok, Instagram o tu aplicación de noticias favorita? Ese feed infinito, aparentemente simple, es una de las características más comunes y cruciales en las aplicaciones móviles modernas. Hoy, el objetivo no es solo construir uno, sino construirlo como lo haría un desarrollador senior en una de las principales empresas de tecnología. Esta guía marca una transición de los ejercicios académicos a la ingeniería de software de nivel profesional.

El enfoque típico de un estudiante podría implicar meter toda la lógica en un solo archivo, mezclar el código de la interfaz de usuario con las llamadas de red y crear una solución que funcione pero que sea difícil de probar, mantener o escalar. El camino profesional es fundamentalmente diferente. Se basa en una filosofía de estructura, separación y calidad. Este tutorial se estructura en torno a tres pilares fundamentales que encarnan esta filosofía: una cadena de herramientas profesional con `very_good_cli` para la creación de proyectos y `dio` para las redes; una base arquitectónica sólida utilizando Arquitectura Limpia y BLoC para la gestión del estado; y un potente socio de IA, `Gemini CLI`, utilizado no para tomar atajos, sino para reforzar el proceso y la calidad.

Al completar esta guía, los estudiantes adquirirán un conjunto de habilidades integral que es directamente aplicable a la industria del desarrollo de software. Los objetivos de aprendizaje están diseñados para construir no solo la competencia técnica, sino una mentalidad profesional:

- Crear proyectos de Flutter listos para producción con una arquitectura escalable y orientada a funcionalidades (feature-first).
- Implementar Arquitectura Limpia para construir funcionalidades que sean modulares, comprobables y mantenibles.
- Utilizar el paquete `dio` para solicitudes de red robustas, configurables y resistentes a errores.
- Dominar el patrón BLoC para gestionar el estado de una funcionalidad compleja y asíncrona.
- Aprovechar `Gemini CLI` como un asistente de flujo de trabajo profesional para la configuración, el aseguramiento de la calidad y la modificación estructurada del código.

### Definiendo la Lógica Central (La Capa de Dominio)

La base de cualquier funcionalidad es su lógica de dominio. Siguiendo el enfoque "feature-first" fomentado por `very_good_cli`, todo el código para esta nueva funcionalidad residirá dentro de un directorio dedicado.

Primero, crea una nueva carpeta: `lib/pokemon_cards/`.

### La Entidad `PokemonCard`

El primer componente de la capa de Dominio es la Entidad. Una entidad representa un objeto de negocio central. Es una clase simple de Dart puro sin dependencias externas.

Crea el archivo `lib/pokemon_cards/domain/entities/pokemon_card.dart`. Esta clase definirá qué es una carta de Pokémon en el contexto de la aplicación. Extiende `Equatable` para permitir una fácil comparación de objetos, lo cual es útil para evitar reconstrucciones innecesarias de la interfaz de usuario.

```dart
import 'package:equatable/equatable.dart';

class PokemonCard extends Equatable {
  const PokemonCard({
    required this.id,
    required this.name,
    required this.imageUrl,
    this.hp,
    this.supertype,
  });

  final String id;
  final String name;
  final String imageUrl;
  final String? hp;
  final String? supertype;

  @override
  List<Object?> get props => [id, name, imageUrl, hp, supertype,];
}
```

**NOTA**: Recuerda instalar la dependencia con el paquete equatable utilizando el comando `pub add`.

### La Interfaz `PokemonCardRepository`

El siguiente componente es la interfaz del Repositorio. Esto no es una implementación concreta, sino una clase abstracta que define un "contrato" para la capa de Datos.16 Especifica los métodos que la capa de Dominio necesita para interactuar con los datos, sin definir *cómo* se obtienen esos datos.

Crea el archivo `lib/pokemon_cards/domain/repositories/pokemon_card_repository.dart`. Esta interfaz declarará un único método requerido por nuestra funcionalidad.

```dart
import 'package:pokecard_dex/pokemon_cards/domain/entities/pokemon_card.dart';

abstract class PokemonCardRepository {
  Future<List<PokemonCard>> getCards({required int page, int pageSize = 20});
}
```

Este código es la capa de Dominio (el "Chef Principal") declarando su necesidad: "Requiero un método llamado `getCards` que acepte un número de página y devuelva un futuro de una lista de entidades `PokemonCard`. No me importa si los datos provienen de una API REST, una caché local o un archivo de texto; cualquier componente que quiera ser un `PokemonCardRepository` debe proporcionar esta funcionalidad".

---

### Obteniendo las Cartas (La Capa de Datos)

El trabajo de la capa de Datos es proporcionar una implementación concreta del contrato del repositorio definido por la capa de Dominio. Maneja toda la comunicación externa, en este caso, obteniendo datos de la API de Pokémon TCG.

### Añadiendo Dependencias

Para manejar las solicitudes de red, se utilizará el potente paquete `dio`. Ofrece un conjunto de características más robusto que el paquete `http` estándar, incluyendo interceptores, mejor manejo de errores y cancelación de solicitudes. Añade `dio` al archivo `pubspec.yaml`, utilizando el siguiente comando:

```bash
flutter pub add dio
```

Luego, instala la nueva dependencia desde la terminal:

```bash
flutter pub get
```

---

### El Modelo `PokemonCardModel`

Mientras que la capa de Dominio tiene su entidad `PokemonCard`, la capa de Datos necesita su propio modelo. Este modelo está diseñado específicamente para coincidir con la estructura de la respuesta JSON de la API externa. Esta separación es crucial para desacoplar la lógica central de la aplicación de los detalles de implementación de un servicio externo.

La API de Pokémon TCG devuelve un objeto JSON para cada carta con muchos campos. El `PokemonCardModel` se diseñará para analizar esta estructura específica.

La dirección en la cual puedes obtener más información acerca del uso de la API es: 

[Welcome to the Pokémon TCG API docs! | Pokémon TCG API Documentation](https://docs.pokemontcg.io/)

Crea el archivo `lib/pokemon_cards/data/models/pokemon_card_model.dart`.

```dart
import 'package:pokecard_dex/pokemon_cards/domain/entities/pokemon_card.dart';

class PokemonCardModel {
  const PokemonCardModel({
    required this.id,
    required this.name,
    required this.images,
    this.hp,
    this.supertype,
  });

  factory PokemonCardModel.fromJson(Map<String, dynamic> json) {
    return PokemonCardModel(
      id: json['id'] as String,
      name: json['name'] as String,
      images: CardImagesModel.fromJson(json['images'] as Map<String, dynamic>),
      hp: json['hp'] as String?,
      supertype: json['supertype'] as String?,
    );
  }

  final String id;
  final String name;
  final CardImagesModel images;
  final String? hp;
  final String? supertype;

  PokemonCard toEntity() {
    return PokemonCard(
      id: id,
      name: name,
      imageUrl: images.large,
      hp: hp,
      supertype: supertype,
    );
  }
}

class CardImagesModel {
  const CardImagesModel({required this.small, required this.large});

  factory CardImagesModel.fromJson(Map<String, dynamic> json) {
    return CardImagesModel(
      small: json['small'] as String,
      large: json['large'] as String,
    );
  }

  final String small;
  final String large;
}

```

Este modelo contiene dos métodos clave:

1. `factory PokemonCardModel.fromJson(...)`: Este constructor es responsable de analizar el mapa JSON crudo y crear un objeto `PokemonCardModel` estructurado.
2. `toEntity()`: Este método mapea el modelo específico de datos a la entidad pura de nivel de dominio `PokemonCard`. Este es el puente que permite a la capa de Datos cumplir el contrato del repositorio de la capa de Dominio.

---

### Implementando el Repositorio

Ahora, es el momento de crear la implementación concreta del `PokemonCardRepository`. Esta clase utilizará `dio` para realizar la solicitud de red real.

Crea el archivo `lib/pokemon_cards/data/repositories/pokemon_card_repository_impl.dart`.

Dart

```dart
import 'package:dio/dio.dart';
import 'package:pokecard_dex/pokemon_cards/data/models/pokemon_card_model.dart';
import 'package:pokecard_dex/pokemon_cards/domain/entities/pokemon_card.dart';
import 'package:pokecard_dex/pokemon_cards/domain/repositories/pokemon_card_repository.dart';

class PokemonCardRepositoryImpl implements PokemonCardRepository {
  PokemonCardRepositoryImpl({Dio? dio}) : _dio = dio?? Dio();

  final Dio _dio;
  final String _baseUrl = 'https://api.pokemontcg.io/v2';

  @override
  Future<List<PokemonCard>> getCards({
    required int page,
    int pageSize = 20,
  }) async {
    try {
      final response = await _dio.get(
        '$_baseUrl/cards',
        queryParameters: {
          'page': page,
          'pageSize': pageSize,
          'orderBy': 'name',
        },
      );

      if (response.statusCode == 200 && response.data!= null) {
        final results = response.data['data'] as List;
        final cards = results
          .map((cardData) =>
                PokemonCardModel.fromJson(cardData as Map<String, dynamic>)
                  .toEntity())
          .toList();
        return cards;
      } else {
        throw Exception('Failed to load Pokémon cards');
      }
    } on DioException catch (e) {
      // Manejar errores específicos de Dio (ej. problemas de red)
      throw Exception('Failed to load Pokémon cards: ${e.message}');
    }
  }
}
```

Esta implementación maneja todo el proceso de obtención de datos:

- Depende de una instancia de `Dio`, que se proporciona a través de su constructor.
- Implementa el método `getCards` definido en el repositorio abstracto.
- Utiliza `_dio.get()` para realizar una solicitud HTTP GET al endpoint `/cards` de la API de Pokémon TCG.18
- Pasa `page` y `pageSize` como parámetros de consulta, según lo especificado por la documentación de la API.20
- Analiza la respuesta JSON, mapea los datos a una lista de objetos `PokemonCardModel` y luego los convierte en entidades `PokemonCard` utilizando el método `toEntity()`.
- Incluye un bloque `try-catch` para manejar posibles errores `DioException` de forma elegante.

La separación explícita de un `Modelo` en la capa de Datos y una `Entidad` en la capa de Dominio no es solo por pureza arquitectónica; es una estrategia crítica para preparar la aplicación para el futuro y hacerla resistente al cambio. Imagina que los mantenedores de la API de Pokémon TCG deciden renombrar el campo `name` en su respuesta JSON a `cardName`. Si la lógica de negocio de la aplicación (en el BLoC) dependiera directamente de la estructura JSON, este cambio externo se propagaría por todo el código base, causando fallos y requiriendo una refactorización extensa. Sin embargo, con esta arquitectura, el cambio se contiene por completo dentro de la capa de Datos. Solo el constructor factory `PokemonCardModel.fromJson` necesitaría ser actualizado. La entidad `PokemonCard`, y consecuentemente todas las capas de Dominio y Presentación, permanecerían completamente intactas y sin conocimiento del cambio en la API externa. Este patrón arquitectónico construye un "cortafuegos", enseñando a los estudiantes que el software robusto no se trata solo de escribir código que funcione hoy, sino de diseñar sistemas que puedan adaptarse con elegancia a los cambios inevitables del mañana.

| **Capa** | **Responsabilidad Clave** | **Componentes de Ejemplo en nuestra App** |
| --- | --- | --- |
| **Presentación** | Mostrar la interfaz de usuario y manejar la entrada del usuario. | `CardsPage`, `CardsView`, `PokemonCardBloc` |
| **Dominio** | Lógica y reglas de negocio centrales. Independiente de cualquier framework. | Entidad `PokemonCard`, interfaz `PokemonCardRepository` |
| **Datos** | Obtener y almacenar datos de fuentes externas (API, BD). | `PokemonCardRepositoryImpl`, `PokemonCardModel`, cliente `Dio` |

---

## Fase 3: Dominio de la Gestión de Estado con BLoC

Con la arquitectura de la aplicación definida, el siguiente paso es gestionar su estado. La gestión de estado es el proceso de manejar datos que cambian con el tiempo y actualizar la interfaz de usuario en respuesta a esos cambios. El patrón BLoC (Business Logic Component) es una forma potente y predecible de gestionar el estado en Flutter, promoviendo una clara separación entre la interfaz de usuario y la lógica de negocio.

### El Patrón BLoC: Un Rápido Repaso

El patrón BLoC puede entenderse usando la analogía de la torre de control de tráfico aéreo de un aeropuerto.

- **Eventos:** Son como los planes de vuelo entrantes presentados por los pilotos (interacciones del usuario desde la interfaz de usuario). Representan una intención de cambiar el estado, como "obtener más cartas" o "actualizar la lista".
- **El Bloc:** Es el Controlador de Tráfico Aéreo. Recibe los planes de vuelo (Eventos), los procesa de acuerdo con un conjunto de reglas (lógica de negocio), se comunica con sistemas externos como el radar y el clima (el Repositorio), y decide el nuevo estado del espacio aéreo.
- **Estados:** Es el tablero público de información de vuelos en la terminal. Representa la única fuente de verdad para la interfaz de usuario en un momento dado (por ejemplo, "cargando", "mostrando 20 cartas", "error al obtener datos"). La interfaz de usuario simplemente observa este tablero y se actualiza cada vez que la información cambia. Nunca habla directamente con el controlador.

Este flujo de datos unidireccional —la interfaz de usuario despacha un Evento, el Bloc procesa el Evento y emite un Estado, la interfaz de usuario se reconstruye en base al Estado— hace que el comportamiento de la aplicación sea predecible y fácil de razonar.

### Definiendo la Conversación (Eventos y Estados)

El primer paso para implementar BLoC es definir la "conversación" entre la interfaz de usuario y la lógica de negocio creando los eventos y estados. Todos los archivos relacionados con BLoC se ubicarán en el directorio `lib/pokemon_cards/bloc/`.

### Eventos (`pokemon_card_event.dart`)

Los eventos son clases simples que representan las entradas al BLoC. Para la funcionalidad de lista infinita, solo se necesita un evento inicialmente.

Crea el archivo `lib/pokemon_cards/bloc/pokemon_card_event.dart`.

```dart
part of 'pokemon_card_bloc.dart';

sealed class PokemonCardEvent extends Equatable {
  const PokemonCardEvent();

  @override
  List<Object> get props => [];
}

final class CardsFetched extends PokemonCardEvent {}
```

La palabra clave `sealed` asegura que todos los posibles subtipos de `PokemonCardEvent` se definan dentro del mismo archivo, haciendo la lógica más robusta.

### Estados (`pokemon_card_state.dart`)

El estado representa los datos que la interfaz de usuario renderizará. Se utiliza una única clase de estado para modelar todos los posibles estados de la interfaz de usuario, desde la carga inicial hasta el éxito y el fracaso.

Crea el archivo `lib/pokemon_cards/bloc/pokemon_card_state.dart`.

```dart
part of 'pokemon_card_bloc.dart';

enum PokemonCardStatus { initial, success, failure }

final class PokemonCardState extends Equatable {
  const PokemonCardState({
    this.status = PokemonCardStatus.initial,
    this.cards = const <PokemonCard>[],
    this.hasReachedMax = false,
  });

  final PokemonCardStatus status;
  final List<PokemonCard> cards;
  final bool hasReachedMax;

  PokemonCardState copyWith({
    PokemonCardStatus? status,
    List<PokemonCard>? cards,
    bool? hasReachedMax,
  }) {
    return PokemonCardState(
      status: status ?? this.status,
      cards: cards ?? this.cards,
      hasReachedMax: hasReachedMax ?? this.hasReachedMax,
    );
  }

  @override
  List<Object> get props => [
    status,
    cards,
    hasReachedMax,
  ];
}

```

Esta clase de estado contiene:

- Un `enum` `PokemonCardStatus` para rastrear el estado de carga actual.
- Una lista de entidades `PokemonCard` para mostrar.
- Un booleano `hasReachedMax` para saber cuándo dejar de buscar más datos.
- Un método `copyWith`. Esta es una parte crucial de la gestión de estado inmutable. En lugar de modificar el estado existente (lo que puede llevar a un comportamiento impredecible), se crea una nueva copia del estado con los valores actualizados.17

### Construyendo el Cerebro (El `PokemonCardBloc`)

El Bloc en sí es la pieza central que conecta eventos, estados y el repositorio. Contiene la lógica de negocio principal para la funcionalidad.

Crea el archivo `lib/pokemon_cards/bloc/pokemon_card_bloc.dart`.

```dart
import 'package:bloc/bloc.dart';
import 'package:bloc_concurrency/bloc_concurrency.dart';
import 'package:equatable/equatable.dart';
import 'package:pokecard_dex/pokemon_cards/domain/entities/pokemon_card.dart';
import 'package:pokecard_dex/pokemon_cards/domain/repositories/pokemon_card_repository.dart';
import 'package:stream_transform/stream_transform.dart';

part 'pokemon_card_event.dart';
part 'pokemon_card_state.dart';

const _throttleDuration = Duration(milliseconds: 100);

EventTransformer<E> throttleDroppable<E>(Duration duration) {
  return (events, mapper) {
    return droppable<E>().call(events.throttle(duration), mapper);
  };
}

class PokemonCardBloc extends Bloc<PokemonCardEvent, PokemonCardState> {
  PokemonCardBloc({required PokemonCardRepository pokemonCardRepository})
      : _pokemonCardRepository = pokemonCardRepository,
        super(const PokemonCardState()) {
    on<CardsFetched>(
      _onCardsFetched,
      transformer: throttleDroppable(_throttleDuration),
    );
  }

  final PokemonCardRepository _pokemonCardRepository;
  int _currentPage = 1;

  Future<void> _onCardsFetched(
    CardsFetched event,
    Emitter<PokemonCardState> emit,
  ) async {
    if (state.hasReachedMax) return;
    try {
      if (state.status == PokemonCardStatus.initial) {
        final cards = await _pokemonCardRepository.getCards(page: _currentPage);
        _currentPage++;
        return emit(state.copyWith(
          status: PokemonCardStatus.success,
          cards: cards,
          hasReachedMax: false,
        ));
      }

      final cards = await _pokemonCardRepository.getCards(page: _currentPage);
      _currentPage++;
      if (cards.isEmpty) {
        emit(state.copyWith(hasReachedMax: true));
      } else {
        emit(state.copyWith(
          status: PokemonCardStatus.success,
          cards: List.of(state.cards)..addAll(cards),
          hasReachedMax: false,
        ));
      }
    } catch (_) {
      emit(state.copyWith(status: PokemonCardStatus.failure));
    }
  }
}
```

Elementos clave de esta implementación incluyen:

- **Inyección de Dependencias:** El `PokemonCardBloc` depende del `PokemonCardRepository` abstracto, no de la implementación concreta. Este repositorio se "inyecta" a través del constructor. Este desacoplamiento es la piedra angular de una arquitectura comprobable.
- **Manejador de Eventos:** El registro `on<CardsFetched>` vincula el evento `CardsFetched` con el método `_onCardsFetched`, que contiene la lógica para manejarlo.
- **Throttling:** El parámetro `transformer` se utiliza con una función `throttleDroppable` de `bloc_concurrency`. Esto evita que el usuario sature la API con eventos de scroll rápidos. Asegura que un nuevo evento `CardsFetched` se procese solo después de que haya pasado una corta duración desde el último, y descarta cualquier evento que llegue mientras uno ya se está procesando.
- **Emisión de Estado:** El `Emitter<PokemonCardState>` se utiliza para emitir nuevos estados. La lógica maneja la obtención inicial, las obtenciones posteriores, el caso en que se alcanza el final de la lista (la API devuelve una lista vacía) y cualquier error potencial del repositorio.

La decisión de hacer que el BLoC dependa de un repositorio *abstracto* es una aplicación práctica del Principio de Inversión de Dependencias (la "D" en SOLID). Esto no es simplemente un ejercicio académico; es lo que desbloquea las pruebas unitarias verdaderas y de nivel profesional. Para probar el `PokemonCardBloc` en completo aislamiento, se deben evitar las llamadas de red reales, que son lentas, poco fiables y una dependencia externa. Debido a que el constructor del BLoC acepta cualquier clase que se ajuste al contrato de `PokemonCardRepository`, se puede crear una versión "mock" o "falsa" del repositorio durante las pruebas utilizando una biblioteca como `mocktail`. Este repositorio mock se puede programar para devolver una lista predefinida de cartas o para lanzar un error a demanda. Esto permite la verificación de cada posible ruta lógica dentro del BLoC —la obtención inicial, las obtenciones posteriores, alcanzar el número máximo de elementos y manejar un fallo de red— sin tocar nunca el paquete `dio` o internet. Esta elección arquitectónica habilita directamente la estrategia de pruebas profesional que es un principio fundamental de la filosofía de `very_good_cli`.

---

## Fase 4: Creando la Interfaz de Usuario

La capa de Presentación es donde el estado de la aplicación se traduce en píxeles en la pantalla. Con la lógica de negocio cuidadosamente encapsulada en el `PokemonCardBloc`, el código de la interfaz de usuario se vuelve declarativo y sencillo. Su única responsabilidad es construir widgets basados en el estado actual y despachar eventos en respuesta a las interacciones del usuario.

### Diseñando los Componentes (La Capa de Widgets)

Para mantener el código de la vista limpio y promover la reutilización, el elemento individual de la lista y el cargador inferior se extraen en sus propios widgets. Estos se colocarán en un directorio `lib/pokemon_cards/widgets/`.

### `card_list_item.dart`

Este es un `StatelessWidget` que recibe una entidad `PokemonCard` y es responsable de mostrar su información.

```dart
import 'package:flutter/material.dart';
import 'package:pokecard_dex/pokemon_cards/domain/entities/pokemon_card.dart';

class CardListItem extends StatelessWidget {
  const CardListItem({required this.card, super.key});

  final PokemonCard card;

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: ListTile(
        leading: Image.network(
          card.imageUrl,
          width: 50,
          fit: BoxFit.contain,
          // Añadir un loading builder para una mejor experiencia de usuario
          loadingBuilder: (context, child, loadingProgress) {
            if (loadingProgress == null) return child;
            return const SizedBox(
              width: 50,
              height: 50,
              child: Center(child: CircularProgressIndicator()),
            );
          },
          // Añadir un error builder para fallos de red
          errorBuilder: (context, error, stackTrace) =>
              const Icon(Icons.error),
        ),
        title: Text(card.name),
        subtitle: Text('HP: ${card.hp?? 'N/A'} - ${card.supertype?? ''}'),
        dense: true,
      ),
    );
  }
}
```

### `bottom_loader.dart`

Este es un `StatelessWidget` simple que proporciona retroalimentación visual al usuario de que se está cargando más contenido.

```dart
import 'package:flutter/material.dart';

class BottomLoader extends StatelessWidget {
  const BottomLoader({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Padding(
        padding: EdgeInsets.all(16.0),
        child: SizedBox(
          height: 24,
          width: 24,
          child: CircularProgressIndicator(strokeWidth: 1.5),
        ),
      ),
    );
  }
}
```

Con estos componentes en su lugar, la interfaz de usuario está completa. Está totalmente desacoplada de la lógica de negocio y la obtención de datos, reaccionando solo a los estados emitidos por el `PokemonCardBloc`.

---

### Conectando la Interfaz de Usuario a la Lógica (La Capa de Vista)

Todos los archivos relacionados con la interfaz de usuario para esta funcionalidad se ubicarán en el directorio `lib/pokemon_cards/view/`. La estructura típicamente consiste en un widget de "página" que proporciona el BLoC y un widget de "vista" que construye la interfaz de usuario.

### La Vista (`cards_view.dart`)

El widget de vista es responsable de renderizar la interfaz de usuario real. Escucha los cambios de estado del `PokemonCardBloc` y construye los widgets apropiados.

Dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:pokecard_dex/pokemon_cards/bloc/pokemon_card_bloc.dart';
import 'package:pokecard_dex/pokemon_cards/widgets/bottom_loader.dart';
import 'package:pokecard_dex/pokemon_cards/widgets/card_list_item.dart';

class CardsView extends StatefulWidget {
  const CardsView({super.key});

  @override
  State<CardsView> createState() => _CardsViewState();
}

class _CardsViewState extends State<CardsView> {
  final _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('PokéCard Dex')),
      body: BlocBuilder<PokemonCardBloc, PokemonCardState>(
        builder: (context, state) {
          switch (state.status) {
            case PokemonCardStatus.failure:
              return const Center(child: Text('Fallo al obtener las cartas'));
            case PokemonCardStatus.success:
              if (state.cards.isEmpty) {
                return const Center(child: Text('No se encontraron cartas'));
              }
              // El ListView.builder irá aquí
              return ListView.builder(
                controller: _scrollController,
                itemCount: state.hasReachedMax
                    ? state.cards.length
                    : state.cards.length + 1,
                itemBuilder: (BuildContext context, int index) {
                  return index >= state.cards.length
                      ? const BottomLoader()
                      : CardListItem(card: state.cards[index]);
                },
              );
            case PokemonCardStatus.initial:
              return const Center(child: CircularProgressIndicator());
          }
        },
      ),
    );
  }

  @override
  void dispose() {
    _scrollController
      ..removeListener(_onScroll)
      ..dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_isBottom) context.read<PokemonCardBloc>().add(CardsFetched());
  }

  bool get _isBottom {
    if (!_scrollController.hasClients) return false;
    final maxScroll = _scrollController.position.maxScrollExtent;
    final currentScroll = _scrollController.position.pixels;
    return currentScroll >= (maxScroll * 0.9);
  }
}

```

Este widget es un `StatefulWidget` porque necesita gestionar el ciclo de vida de un `ScrollController`. El controlador se inicializa en `initState`, se le añade un listener y se desecha correctamente en `dispose` para evitar fugas de memoria, una mejor práctica crítica.

### Construyendo el Scroll Infinito

El núcleo de la interfaz de usuario es el `BlocBuilder`, que reconstruye su árbol de widgets hijos en respuesta a nuevos estados del BLoC.

### Interfaz de Usuario Dirigida por el Estado

La función `builder` del `BlocBuilder` utilizará una declaración `switch` sobre el `state.status` para determinar qué mostrar. Esta es la esencia de una interfaz de usuario declarativa.

```dart
// Dentro de la función builder del BlocBuilder en cards_view.dart
switch (state.status) {
  case PokemonCardStatus.failure:
    return const Center(child: Text('Fallo al obtener las cartas'));
  case PokemonCardStatus.success:
    if (state.cards.isEmpty) {
      return const Center(child: Text('No se encontraron cartas'));
    }
    // El ListView.builder irá aquí
  case PokemonCardStatus.initial:
    return const Center(child: CircularProgressIndicator());
}
```

### El `ListView.builder`

Cuando el estado es `success`, se utiliza un `ListView.builder` para renderizar eficientemente la lista de cartas.

```dart
// Dentro del caso success de la declaración switch
return ListView.builder(
  controller: _scrollController,
  itemCount: state.hasReachedMax
    ? state.cards.length
      : state.cards.length + 1,
  itemBuilder: (BuildContext context, int index) {
    return index >= state.cards.length
      ? const BottomLoader()
        : CardListItem(card: state.cards[index]);
  },
);
```

Esta implementación contiene dos piezas clave de lógica:

1. `itemCount`: Un cálculo inteligente determina el número de elementos en la lista. Si `hasReachedMax` es verdadero, el conteo es simplemente el número de cartas. Si no, se añade un espacio extra al final de la lista para albergar el indicador de carga.17
2. `itemBuilder`: Para cada índice, comprueba si el índice es para una carta o para el espacio de carga extra. Si `index >= state.cards.length`, renderiza el widget `BottomLoader`. De lo contrario, renderiza un `CardListItem` para la carta en ese índice.

### La Lógica del `ScrollController`

El método `_onScroll`, adjunto al `ScrollController`, es el disparador para obtener más datos.

```dart
// En _CardsViewState
void _onScroll() {
  if (_isBottom) context.read<PokemonCardBloc>().add(CardsFetched());
}

bool get _isBottom {
  if (!_scrollController.hasClients) return false;
  final maxScroll = _scrollController.position.maxScrollExtent;
  final currentScroll = _scrollController.position.pixels;
  // Obtener cuando el usuario está al 90% del final
  return currentScroll >= (maxScroll * 0.9);
}
```

Esta lógica calcula si el usuario se ha desplazado cerca del final del contenido actual. Cuando se alcanza este umbral, utiliza `context.read<PokemonCardBloc>()` para acceder a la instancia del BLoC y añadir un nuevo evento `CardsFetched`, desencadenando la carga de la siguiente página de datos.

---

### La Página (`cards_page.dart`)

El widget de página es el punto de entrada para la interfaz de usuario de la funcionalidad. Es un `StatelessWidget` simple cuyo trabajo principal es crear y proporcionar el `PokemonCardBloc` a sus widgets hijos utilizando el widget `BlocProvider` del paquete `flutter_bloc`.

Dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:pokecard_dex/pokemon_cards/bloc/pokemon_card_bloc.dart';
import 'package:pokecard_dex/pokemon_cards/data/repositories/pokemon_card_repository_impl.dart';
import 'package:pokecard_dex/pokemon_cards/view/cards_view.dart';

class CardsPage extends StatelessWidget {
  const CardsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => PokemonCardBloc(
        pokemonCardRepository: PokemonCardRepositoryImpl(),
      )..add(CardsFetched()),
      child: const CardsView(),
    );
  }
}
```

En esta configuración, `BlocProvider` instancia el `PokemonCardBloc`, proporcionándole la implementación concreta `PokemonCardRepositoryImpl`. Crucialmente, añade inmediatamente el evento inicial `CardsFetched`. Esta acción inicia el proceso de carga de datos tan pronto como se construye la interfaz de usuario de la funcionalidad.

El proyecto generado por `very_good_cli` viene con una página de contador por defecto. El paso final es simplemente reemplazar esa página de contador con la `CardsPage` que hemos construido.

Aquí te muestro cómo hacerlo:

1. **Abre el archivo `lib/app/view/app.dart`**.
2. **Importa tu nueva `CardsPage`** en la parte superior del archivo.
3. **Reemplaza `CounterPage()` por `CardsPage()`** en la propiedad `home` del `MaterialApp`.

El archivo modificado debería verse así:

```
import 'package:flutter/material.dart';
import 'package:pokecard_dex/l10n/l10n.dart';
import 'package:pokecard_dex/pokemon_cards/view/cards_page.dart';

class App extends StatelessWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData(
        appBarTheme: AppBarTheme(
          backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        ),
        useMaterial3: true,
      ),
      localizationsDelegates: AppLocalizations.localizationsDelegates,
      supportedLocales: AppLocalizations.supportedLocales,
      home: const CardsPage(),
    );
  }
}

```

---

### Preparemos nuestro proyecto para el lanzamiento

El proyecto generado por `very_good_cli` viene con una página de contador por defecto. El paso final es simplemente reemplazar esa página de contador con la `CardsPage` que hemos construido.

Aquí te muestro cómo hacerlo:

1. **Abre el archivo `lib/app/view/app.dart`**.
2. **Importa tu nueva `CardsPage`** en la parte superior del archivo.
3. **Reemplaza `CounterPage()` por `CardsPage()`** en la propiedad `home` del `MaterialApp`.

El archivo modificado debería verse así:

```dart
import 'package:flutter/material.dart';
// Importa la página que creamos
import 'package:pokecard_dex/pokemon_cards/view/cards_page.dart'; 
import 'package:pokecard_dex/l10n/l10n.dart';

class App extends StatelessWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData(
        appBarTheme: const AppBarTheme(color: Color(0xFF13B9FF)),
        colorScheme: ColorScheme.fromSwatch(
          accentColor: const Color(0xFF13B9FF),
        ),
      ),
      localizationsDelegates: AppLocalizations.localizationsDelegates,
      supportedLocales: AppLocalizations.supportedLocales,
      // Aquí está el cambio: reemplaza la página de contador por defecto
      // con la nueva página de la lista de cartas.
      home: const CardsPage(),
    );
  }
}
```

---

### Ejecuta la aplicación

Finalmente ejecuta la aplicación, utilizando el siguiente comando:

```bash
flutter run --flavor development -t lib/main_development.dart
```

---

## Fase 5: El Flujo de Trabajo Profesional - Calidad Asistida por IA y Próximos Pasos

El desarrollo de software profesional no se trata solo de escribir código que funcione; se trata de escribir código de alta calidad y mantenible y seguir un proceso disciplinado. Esta fase final se centra en integrar el copiloto de IA en el flujo de trabajo para reforzar la calidad y explorar futuras rutas de desarrollo.

### Tu Puerta de Calidad de IA: El Comando `/commit`

Un commit en Git debe representar una unidad de trabajo única, completa y de alta calidad. Antes de hacer un commit, un desarrollador profesional realiza típicamente una serie de comprobaciones: formatear el código, ejecutar un analizador estático para detectar posibles errores y ejecutar pruebas para asegurarse de que nada se ha roto. La Extensión de Flutter para Gemini CLI puede automatizar toda esta lista de verificación previa al commit con un solo comando.5

### El Flujo de Trabajo

En lugar del proceso manual de `git commit`, el flujo de trabajo se vuelve asistido por IA.

1. Primero, visualiza los archivos modificados usando `git status`.
2. A continuación, prepara todos los cambios para el commit con `git add .`.
3. Finalmente, en lugar de escribir un mensaje de commit manual, invoca al copiloto de IA:
    
    ```dart
    gemini
    /commit
    ```
    

### Explicación del Proceso

Cuando se ejecuta el comando `/commit`, Gemini realiza una secuencia de comprobaciones de calidad de nivel profesional en el código preparado :

- **Formateo de Código:** Ejecuta `dart format` y `dart fix` para asegurar que todo el código nuevo se adhiera a las directrices de estilo establecidas del proyecto. Esto elimina inconsistencias estilísticas y mejora la legibilidad.
- **Análisis Estático:** Ejecuta `flutter analyze` (o `dart analyze`), que actúa como un corrector ortográfico y gramatical para el código. Detecta errores potenciales, violaciones de estilo y otros problemas antes de que se conviertan en errores en tiempo de ejecución.
- **Pruebas:** Ejecuta el conjunto de pruebas del proyecto (`flutter test`) para verificar que los nuevos cambios no hayan introducido ninguna regresión o roto la funcionalidad existente.
- **Generación de Mensaje de Commit:** Después de que todas las comprobaciones hayan pasado, Gemini analiza los cambios en el código (el `git diff`) y genera un mensaje de commit descriptivo y bien formateado que resume el trabajo realizado. Luego, se le pide al estudiante que revise, edite y apruebe este mensaje antes de que se finalice el commit.

Este proceso transforma la IA de un simple generador de código en un socio de aseguramiento de la calidad. No es un atajo que elude la comprensión; más bien, es una herramienta que automatiza y refuerza los hábitos disciplinados de un desarrollador senior, asegurando que cada commit contribuya a una base de código saludable y estable.

### Modo Desafío: Expandiendo tu Universo

La mejor manera de consolidar nuevos conocimientos es aplicarlos a nuevos problemas. Los siguientes desafíos están diseñados para fomentar el aprendizaje autodirigido y construir sobre los conceptos cubiertos en esta guía.

### Desafío 1: La Vista de Detalle

Cuando un usuario toca una carta en la lista, debe ser llevado a una nueva pantalla que muestre más detalles sobre esa carta. Esto requerirá la integración del paquete `go_router`, con el que los estudiantes tienen experiencia previa. Necesitarán definir una nueva ruta, pasar el ID de la carta como parámetro y crear una nueva funcionalidad (o al menos una nueva página) para obtener y mostrar los detalles completos de una sola carta utilizando el endpoint `https://api.pokemontcg.io/v2/cards/<id>`.

puedes consultar más detalles en:

[Welcome to the Pokémon TCG API docs! | Pokémon TCG API Documentation](https://docs.pokemontcg.io/)

### Desafío 2: Pull-to-Refresh

Implementa la funcionalidad de "tirar para refrescar". Cuando el usuario tira hacia abajo desde la parte superior de la lista, la lista existente debe borrarse y la primera página de cartas debe obtenerse de nuevo. Esto implicará crear un nuevo evento, como `CardsRefreshed`, y añadir un manejador para él en el `PokemonCardBloc`. La interfaz de usuario necesitará ser envuelta en un widget `RefreshIndicator`.

### Desafío 3: Prueba tu Lógica

La plantilla de `very_good_cli` proporciona una excelente base para las pruebas.12 El siguiente paso lógico es escribir una prueba unitaria para el `PokemonCardBloc`. Esto refuerza directamente los beneficios arquitectónicos discutidos en la Fase 3. La prueba debe:

- Usar el paquete `mocktail` para crear una implementación mock del `PokemonCardRepository`.
- Usar el paquete `bloc_test` para escribir pruebas que verifiquen el comportamiento del BLoC.
- Probar el caso de éxito: cuando el repositorio mock devuelve una lista de cartas, afirmar que el BLoC emite estados `[success]` con los datos correctos.
- Probar el caso de fallo: cuando el repositorio mock lanza una excepción, afirmar que el BLoC emite un estado `[failure]`.

### Desafío 4: Refactorización Guiada con IA

La interfaz de usuario para el `CardListItem` es actualmente simple. una tarea común para un desarrollador es refactorizar componentes existentes para añadir nueva información o cambiar el diseño. Este es un escenario ideal para usar las capacidades de modificación de código estructurado de Gemini. Los estudiantes deben usar el comando `/modify`(o `/refactor`) para guiar este proceso.

El prompt podría ser:

```dart
gemini
/modify Cambia el CardListItem para mostrar el HP y el tipo de la carta debajo de su nombre.
```

Los estudiantes deben observar el proceso. Gemini primero pedirá una aclaración sobre los objetivos, ofrecerá crear una nueva rama de Git para aislar el trabajo y luego generará un archivo `MODIFICATION_PLAN.md`. Este plan describe los cambios propuestos *antes* de que se escriba cualquier código.5 Esto enseña un enfoque proactivo y planificado para la refactorización, que es mucho más seguro y eficiente que sumergirse directamente en el código.

### Desafío 5: Búsqueda por Nombre (Asistida por IA)

Mejora la aplicación añadiendo una barra de búsqueda para encontrar un Pokémon por su nombre. Este es un excelente caso de uso para la refactorización guiada por IA.

- **Objetivo:** Añadir un `TextField` en el `AppBar` para que los usuarios puedan escribir un nombre y ver los resultados.
- **Plan de Acción con IA:** Inicia una sesión de modificación con Gemini (`/modify`) para añadir un campo de búsqueda a la `CardsView`.
- **Implementación:**
    1. **Evento del BLoC:** Crea un nuevo evento, como `CardsSearched(String query)`, para manejar las búsquedas.
    2. **Lógica del BLoC:** En el `PokemonCardBloc`, maneja el nuevo evento. Deberás limpiar la lista actual de cartas, reiniciar el contador de página y llamar a un nuevo método en tu repositorio.
    3. **Capa de Datos:** Modifica la interfaz `PokemonCardRepository` para incluir un método como `searchCards({required String name, required int page})`. En la implementación, utiliza el parámetro de consulta `q` de la API con la sintaxis `name:el_nombre_buscado*` para permitir búsquedas parciales.

### Desafío 6: Filtrado Avanzado por Tipo (Asistida por IA)

Lleva la aplicación al siguiente nivel implementando un filtro por tipo de Pokémon usando un `Drawer`.

- **Objetivo:** Permitir a los usuarios abrir un menú lateral (Drawer) y seleccionar uno o más tipos de Pokémon (ej. "Fuego", "Agua") para filtrar la lista de cartas.
- **Plan de Acción con IA:** Usa el comando `/modify` de Gemini para añadir un `Drawer` al `Scaffold` en `CardsView`. Pídele que lo pueble con una lista de `CheckboxListTile` para los diferentes tipos de Pokémon.
- **Implementación:**
    1. **Estado del BLoC:** Amplía `PokemonCardState` para que pueda almacenar los filtros activos (ej. `final Set<String> activeFilters`). No olvides actualizar el método `copyWith`.
    2. **Evento del BLoC:** Crea un evento como `FilterChanged(Set<String> newFilters)`.
    3. **Lógica del BLoC:** Cuando se reciba el evento `FilterChanged`, actualiza el estado con los nuevos filtros, limpia la lista de cartas, reinicia la paginación y realiza una nueva llamada al repositorio con los filtros aplicados.
    4. **Capa de Datos:** Actualiza tu repositorio para aceptar una lista de tipos. La consulta a la API deberá construirse dinámicamente. Por ejemplo, si se seleccionan "Agua" y "Fuego", el parámetro `q` debería ser `types:(water OR fire)`.

---

> **NOTA**: Recuerda que es fundamental que tu app este personalizada con un icono y un splash adecuado a la aplicación; así como todo tu código debe encontrarse resguardado en un repositorio de Git
>